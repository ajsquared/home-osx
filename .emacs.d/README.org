* Emacs Configuration
This file contains all my Emacs configuration in a literate style with org-babel-mode.

There is a small amount of configuration that must live in other locations:
1. =~/.emacs.d/early-init.el=: Changes GC settings for faster startup.
2. =~/.emacs.d/custom.el=: Put the autogenerated settings from Custom in this file to avoid polluting the main init files.

** Package Setup
Emacs has a built-in package manager. In general I will use use-package to manage package installation, but a bit of configuration is first necessary to support this. use-package does a lot:
- Ensures that packages I want are automatically installed
- Allows controlling when packages are loaded
- Supports putting package customization in a standard location/format

Altogether it is much nicer than the older system of manually installing packages and using =require= to load them.

First initialize the package system with the standard archives. MELPA has the most up-to-date versions of most packages.
#+BEGIN_SRC emacs-lisp
(require 'package)

(setq package-archives '(("gnu" . "http://elpa.gnu.org/packages/")
                         ("melpa" . "https://melpa.org/packages/")))

(package-initialize)
#+END_SRC

Then set up use-package so it is ready to go for the next parts of this configuration.
#+BEGIN_SRC emacs-lisp
(unless (package-installed-p 'use-package)
  (package-install 'use-package))
(require 'use-package)

(setq use-package-always-ensure t)
#+END_SRC

Next I bind a shortcut to list all available packages:
#+BEGIN_SRC emacs-lisp
(bind-key "C-c p l" 'package-list-packages)
#+END_SRC

Finally I want to ensure that packages stay up to date automatically using the auto-package-update package. This is the first use of use-package in my configuration.
#+BEGIN_SRC emacs-lisp
(use-package auto-package-update
  :ensure t
  :custom
  (auto-package-update-delete-old-versions t)
  (auto-package-update-hide-results t)
  :config
  (auto-package-update-maybe))
#+END_SRC
** Base Configuration
After setting up package management, I can move on to actual Emacs configuration. The first thing I will configure is some basic functionality that applies globally regardless of what task I am performing in Emacs.
*** Custom
To have Custom put its settings in a different file, we need to configure a separate file and tell Emacs to load it:
#+BEGIN_SRC emacs-lisp
(setq custom-file "~/.emacs.d/custom.el")
(load custom-file)
#+END_SRC
*** Miscellaneous Settings
Here there are several settings that don't fit into any other section.

First, I change the behavior of Emacs startup so it opens to a plain-text scratch buffer in my home directory:
#+BEGIN_SRC emacs-lisp
(setq default-directory "~/")
(setq initial-major-mode 'text-mode)
(setq inhibit-startup-message t)
(setq initial-scratch-message nil)
#+END_SRC

Enable replacing selected text when typing/pasting:
#+BEGIN_SRC emacs-lisp
(delete-selection-mode)
#+END_SRC

Enable the OS clipboard when copying/cutting text:
#+BEGIN_SRC emacs-lisp
(setq select-enable-clipboard t)
#+END_SRC

Require a final newline in files:
#+BEGIN_SRC emacs-lisp
(setq require-final-newline t)
#+END_SRC

Put backup files in a temporary directory instead of the current directory:
#+BEGIN_SRC emacs-lisp
(setq backup-directory-alist
      `((".*" . ,temporary-file-directory)))
(setq tramp-backup-directory-alist backup-directory-alist)
#+END_SRC

Define the file in which abbrev-mode stores abbreviations:
#+BEGIN_SRC emacs-lisp
(setq abbrev-file-name "~/.emacs.d/.abbrev")
#+END_SRC

Ignore case when entering file names:
#+BEGIN_SRC emacs-lisp
(setq read-file-name-completion-ignore-case t)
#+END_SRC

Do not require typing out =yes= or =no= for confirmation, just =y= or =n=:
#+BEGIN_SRC emacs-lisp
(fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC

Finally, I disable the bell for certain commands that ring it frequently:
#+BEGIN_SRC emacs-lisp
(setq ring-bell-function 
      (lambda ()
	(unless (memq this-command
		      '(isearch-abort
			abort-recursive-edit
			exit-minibuffer
			keyboard-quit
			mwheel-scroll
			down
			up
			next-line
			previous-line
			backward-char
			forward-char))
	  (ding))))
#+END_SRC
*** Auto-save
Next I will change the default auto-save behavior.

First I want to put the auto-save files into the system's temp directory rather than polluting the current directory:
#+BEGIN_SRC emacs-lisp
(setq auto-save-file-name-transforms
      `((".*" ,temporary-file-directory t)))
(setq auto-save-list-file-prefix temporary-file-directory)
#+END_SRC
Then I change the interval at which Emacs autosaves so it is frequent, but not too frequent:
#+BEGIN_SRC emacs-lisp
(setq auto-save-interval 1000)
(setq auto-save-timeout 120)
#+END_SRC
Finally, I have a custom hook to save files in place instead of to a separate file:
#+BEGIN_SRC emacs-lisp
(defun save-buffer-if-visiting-file (&optional args)
  "Save the current buffer only if it is visiting a file"
  (interactive)
  (if (and (buffer-file-name) (buffer-modified-p))
      (save-buffer args)))
(add-hook 'auto-save-hook #'save-buffer-if-visiting-file)
#+END_SRC
*** Client Exit
I use emacsclient as my =$EDITOR= in my shell, so things like writing a git commit message will open Emacs. I want to have consistency for killing such buffers as with normal buffers, so I have a custom hook to set my prefered =C-x C-k= keybinding when this happens:
#+BEGIN_SRC emacs-lisp
(defun client-exit-setup ()
  (when (current-local-map)
    (use-local-map (copy-keymap (current-local-map))))
  (when server-buffer-clients
    (local-set-key (kbd "C-x C-k") 'server-edit)))
(add-hook 'server-switch-hook #'client-exit-setup)

#+END_SRC
** UI and Appearance
The next thing I will configure is the UI and appearance of Emacs.
*** OS X
Emacs needs a few tweaks to work properly in OS X.

First I want to remap the modifier keys so my muscle memory lines up. Then, if I am running GUI Emacs, I want to set a nicer font and maximize the window. Finally, I have to explicitly load the =PATH= environment variable as GUI Emacs does not load that properly otherwise. I need the exec-path-from-shell package for this.
#+BEGIN_SRC emacs-lisp
(use-package exec-path-from-shell
  :ensure t
  :defer t
  :custom
  (exec-path-from-shell-arguments '("-l")))

(when (eq system-type 'darwin)
  (setq mac-control-modifier 'meta)
  (setq mac-command-modifier 'control)
  (when (window-system)
    (exec-path-from-shell-initialize)
    (add-to-list 'default-frame-alist '(fullscreen . maximized))
    (set-face-attribute 'default nil :font "Monaco-14")))
#+END_SRC
*** Basic UI Tweaks
Next I make some basic tweaks to the UI.

First I customize the title of the Emacs window (aka "frame") to show the version and path to the current file:
#+BEGIN_SRC emacs-lisp
(setq frame-title-format
      '("Emacs " emacs-version ": "(:eval (if (buffer-file-name)
                                              (abbreviate-file-name (buffer-file-name))
                                            "%b"))))
#+END_SRC

Next I disable the toolbar, scrollbar, and menu as I find them unncessary:
#+BEGIN_SRC emacs-lisp
(tool-bar-mode -1)
(scroll-bar-mode -1)
(menu-bar-mode nil)
#+END_SRC

Then I enable hl-line-mode to easily see what line the cursor is on:
#+BEGIN_SRC emacs-lisp
(global-hl-line-mode t)
#+END_SRC

Next, enable display of line and column numbers:
#+BEGIN_SRC emacs-lisp
(global-linum-mode)
(column-number-mode 1)
#+END_SRC

Then enable navigating through subwords when text is in camel case:
#+BEGIN_SRC emacs-lisp
(global-subword-mode)
#+END_SRC

Then enable the mouse wheel:
#+BEGIN_SRC emacs-lisp
(mouse-wheel-mode t)
(setq mouse-drag-copy-region nil)
#+END_SRC

Next enables font-lock (aka syntax highlighting) globally:
#+BEGIN_SRC emacs-lisp
(global-font-lock-mode t)
#+END_SRC

Then enable highlighting matching pairs of brackets:
#+BEGIN_SRC emacs-lisp
(show-paren-mode)
(setq show-paren-style 'parenthesis)
#+END_SRC

Next enable the diminish package to hide some minor modes from the modeline that I don't find useful:
#+BEGIN_SRC emacs-lisp
(use-package diminish
  :ensure t
  :config
  (diminish 'subword-mode))
#+END_SRC

Finally, turn the cursor into a bar:
#+BEGIN_SRC emacs-lisp
(use-package bar-cursor
  :ensure t
  :diminish
  :config
  (bar-cursor-mode 1))
#+END_SRC
*** Color Theme
The final component of the appearance tweaks is to enable a color theme.

I like to use the doom-one theme:
#+BEGIN_SRC emacs-lisp
(use-package doom-themes
  :ensure t
  :config
  (load-theme 'doom-one t))
#+END_SRC

As part of this I also enable a nicer looking modeline, using the spaceline package extracted from Spacemacs. I defer loading this slightly to speed up startup. I use Helm (to be configured later) so I enable the integration here too.
#+BEGIN_SRC emacs-lisp
(use-package spaceline
  :ensure t
  :defer 2
  :config
  (spaceline-emacs-theme)
  (spaceline-helm-mode))
#+END_SRC

And at last I enable rainbox-delimiters-mode to color each successive pair of brackets differently. I find this useful for visually scanning blocks of code.
#+BEGIN_SRC emacs-lisp
(use-package rainbow-delimiters
  :ensure t
  :hook (prog-mode . rainbow-delimiters-mode))
#+END_SRC
** Text and Code Editing
The next section in my configuration customizes text and code editing.

First I have some standard indentation configuration:
#+BEGIN_SRC emacs-lisp
(setq c-default-style "bsd")
(setq tab-width 2)
(setq c-basic-offset 2)
(setq-default indent-tabs-mode nil)
#+END_SRC

Then I rebind several standard functions to keys I prefer
#+BEGIN_SRC emacs-lisp
(bind-key "RET" 'newline-and-indent)
(bind-key "C-x C-k" 'kill-this-buffer)
(bind-key "C-c r" 'replace-string)
(bind-key "C-c s" 'isearch-forward)
(bind-key "C-z" 'undo)
(bind-key "M-g" 'goto-line)
(bind-key "C-c c" 'comment-region)
(bind-key "C-c u" 'uncomment-region)
(bind-key "M-m" 'move-beginning-of-line)
(bind-key "C-a" 'back-to-indentation)

#+END_SRC

And I have a custom function to enable opening the current file with sudo if it is necessary to gain root access:
#+BEGIN_SRC emacs-lisp
(defun find-alternative-file-with-sudo ()
  (interactive)
  (let ((fname (or buffer-file-name
		   dired-directory)))
    (when fname
      (if (string-match "^/sudo:root@localhost:" fname)
	  (setq fname (replace-regexp-in-string
		       "^/sudo:root@localhost:" ""
		       fname))
	(setq fname (concat "/sudo:root@localhost:" fname)))
      (find-alternate-file fname))))
(bind-key "C-x C-r" 'find-alternative-file-with-sudo)
#+END_SRC

Then I enable auto-revert-mode to automatically update files that change externally to Emacs (such as external formatters or git checkouts):
#+BEGIN_SRC emacs-lisp
(global-auto-revert-mode)
#+END_SRC

*** Git
I use Magit for interacting with Git from Emacs. It is a very robust and featureful interface and remains one of the best interfaces to Git I have used.

Here I install Magit and enable some keybindings for it:
#+BEGIN_SRC emacs-lisp
(use-package magit
  :ensure t
  :custom
  (magit-git-executable "/usr/local/bin/git")
  (vc-follow-symlinks t)
  :bind (("C-x v" . magit-status)
         ("C-x f" . magit-log-buffer-file)
         ("C-x l" . magit-blame)))
#+END_SRC

I also enable git-commit-mode for better editing of commit messages:
#+BEGIN_SRC emacs-lisp
(use-package git-commit
  :ensure t
  :config
  (global-git-commit-mode))
#+END_SRC

*** Autopair
Autopair automatically inserts the matching character for paired characters like quotes and brackets. It can be configured more for certain languages, but its base setup works well globally:
#+BEGIN_SRC emacs-lisp
(use-package autopair
  :ensure t
  :diminish
  :custom
  (autopair-autowrap t)
  :config
  (autopair-global-mode 1))
#+END_SRC
*** YASnippet
YASnippet allows automatic expansion of text snippets. I don't use this much, but it is handy for some common templates, especially as it can run Elisp code as part of the expansion.
#+BEGIN_SRC emacs-lisp
(use-package yasnippet
  :ensure t
  :diminish yas-minor-mode
  :config
  (yas-global-mode 1)
  :bind (("C-c y" . yas-expand-from-trigger-key)))
#+END_SRC
*** Project Management
When working in Emacs I am generally working on a specific project. I've added some packages for making this easier.

First is Perspective. This allows defining "groups" of buffers and activating one group at a time. This is convenient for switching between projects without losing my open buffers:
#+BEGIN_SRC emacs-lisp
(use-package perspective
  :ensure t
  :config
  (persp-mode)
  (persp-turn-on-modestring))
#+END_SRC

Next is Projectile. This is the core project management package for Emacs. It figures out projects automatically based on Git repositories and then allows better navigation within the project.

I use its caching functionality to speed up navigation on large projects, so I have added some custom functions to invalidate the cache when changing projects and on Emacs startup.
#+BEGIN_SRC emacs-lisp
(use-package projectile
  :ensure t
  :custom
  (projectile-enable-caching t)
  :config
  (projectile-mode)
  :init
  (defun projectile-switch-project-setup ()
    (projectile-invalidate-cache nil))
  (add-hook 'projectile-after-switch-project-hook #'projectile-switch-project-setup)
  
  (defun projectile-init-setup ()
    (mapc (lambda (project-root)
            (remhash project-root projectile-project-type-cache)
            (remhash project-root projectile-projects-cache)
            (remhash project-root projectile-projects-cache-time)
            (when projectile-verbose
              (message "Invalidated Projectile cache for %s."
                       (propertize project-root 'face 'font-lock-keyword-face)))
            (when (fboundp 'recentf-cleanup)
              (recentf-cleanup)))
          (hash-table-keys projectile-projects-cache))
    (projectile-serialize-cache))
  (add-hook 'after-init-hook #'projectile-init-setup))
#+END_SRC

Finally I have neotree, which provides a tree view of a project. I don't find this very useful most of the time, but it is nice when exploring unfamiliar projects at least.

I've added all-the-icons as well for a nicer looking tree view with icons.
#+BEGIN_SRC emacs-lisp
(use-package all-the-icons
  :ensure t
  :defer t)

(use-package neotree
  :ensure t
  :defer t
  :custom
  (neo-theme (if (display-graphic-p) 'icons 'arrow))
  (neo-smart-open t)
  :bind ("C-c p n" . neotree-toggle)
  :after (all-the-icons))

#+END_SRC
*** Searching and Navigation
Now that I have some notion of a project, I want to be able to search across it. I use ripgrep on the command line, and the rg package is the Emacs interface to it:
#+BEGIN_SRC emacs-lisp
(use-package rg
  :ensure t
  :custom
  (rg-executable "/usr/local/bin/rg")
  :bind (("C-c a" . rg-project)))
#+END_SRC

Then I use the dumb-jump package for navigating to symbols. I've never liked etags, and dumb-jump gets most of the way to the same thing by searching with rg for the symbol at the cursor:
#+BEGIN_SRC emacs-lisp
(use-package dumb-jump
  :ensure t
  :custom
  (dumb-jump-force-searcher 'rg)
  :init
  (add-hook 'xref-backend-functions #'dumb-jump-xref-activate))
#+END_SRC
*** Completion
Finally I want to enable good completion and fuzzy matching everywhere possible. Helm is the gold standard for this in Emacs. It provides fast completion and matching and integrates to basically everything.

I first want to enable Helm and add a bunch of useful keybindings
#+BEGIN_SRC emacs-lisp
(use-package helm
  :ensure t
  :diminish
  :custom
  (helm-scroll-amount 4)
  (helm-quick-update t)
  (helm-idle-delay 0.01)
  (helm-input-idle-delay 0.01)
  (helm-ff-search-library-in-sexp t)
  (helm-split-window-default-side 'other)
  (helm-split-window-in-side-p t)
  (helm-candidate-number-limit 200)
  (helm-M-x-requires-pattern 0)
  (helm-ff-skip-boring-files t)
  (helm-boring-file-regexp-list
        '("\\`\\." "\\`#" "\\`.#" "\\`\\.\\./" "\\`\\./" "\\`\\.git/" "\\.pdf" "\\.class" "\\.pyc" "\\.log" "\\.aux" "\\.nav" "\\.out" "\\.snm" "\\.elc"))
  (helm-ff-file-name-history-use-recentf t)
  (helm-move-to-line-cycle-in-source t)
  (ido-use-virtual-buffers t)
  (helm-buffers-fuzzy-matching t)
  (recentf-exclude
        '("COMMIT_EDITMSG" "\\.emacs\\.d/elpa"))
  :config
  (require 'helm-config)
  (require 'helm-files)
  (require 'helm-grep)
  (helm-mode 1)
  (helm-descbinds-mode)
  :init
  (add-hook 'helm-goto-line-before-hook 'helm-save-current-pos-to-mark-ring)
  :bind (("M-x" . helm-M-x)
         ("M-y" . helm-show-kill-ring)
         ("C-x b" . helm-mini)
         ("C-x C-f" . helm-find-files)
         ("C-c h f" . helm-find)
         ("C-c h l" . helm-locate)
         ("C-s" . helm-occur)
         ("C-c h r" . helm-resume)
         :map helm-map
         ("<tab>" . helm-execute-persistent-action)
         ("C-i" . helm-execute-persistent-action)
         ("C-z" . helm-select-action)
         :map helm-grep-mode-map
         ("<return>" . helm-grep-mode-jump-other-window)
         ("n" . helm-grep-mode-jump-other-window-forward)
         ("p" . helm-grep-mode-jump-other-window-backward)
         :map help-map
         ("C-f" . helm-apropos)
         ("r" . helm-info-emacs)))
#+END_SRC

Helm integrates with Projectile to make project management better:
#+BEGIN_SRC emacs-lisp
(use-package helm-projectile
  :ensure t
  :bind (("C-c p h" . helm-projectile)
         ("C-c p s" . helm-projectile-switch-project)))
#+END_SRC

Company is an autocompletion framework for Emacs that also is well-integrated in the ecosystem. It also plugs into Helm nicely:
#+BEGIN_SRC emacs-lisp
(use-package company
  :ensure t
  :hook (prog-mode . company-mode))

(use-package helm-company
  :ensure t
  :after (helm company)
  :bind (:map company-mode-map
              ("C-;" . helm-company)))
#+END_SRC

There are also some miscellaneous Helm integrations:
#+BEGIN_SRC emacs-lisp
(use-package helm-descbinds
  :ensure t
  :after (helm))

(use-package helm-xref
  :ensure t)
#+END_SRC
** Programming Modes
Emacs comes with a lot of built-in modes for programming, but it doesn't have everything. I've also wanted to customize the built-in functionality as well. This next section contains all my programming language-specific settings.
*** Markdown
markdown-mode provides a better experience for Markdown, including Github-flavored Markdown, which I prefer:
#+BEGIN_SRC emacs-lisp
(use-package markdown-mode
  :ensure t
  :config
  (add-to-list 'auto-mode-alist '("\\.markdown" . gfm-mode))
  (add-to-list 'auto-mode-alist '("\\.md" . gfm-mode)))
#+END_SRC
*** JSON
Emacs doesn't have a good built-in mode for editing JSON files:
#+BEGIN_SRC emacs-lisp
(use-package json-mode
  :ensure t
  :config
  (add-to-list 'auto-mode-alist '("\\.json" . json-mode)))
#+END_SRC
*** LaTeX
I use Auctex for editing LaTeX. I don't use LaTeX for much anymore, mainly just my resume, but I used it extensively in undergrad and grad school for typing up assignments.
#+BEGIN_SRC emacs-lisp
(use-package tex
  :ensure auctex
  :custom
  (TeX-auto-save t)
  (TeX-parse-self t)
  (TeX-newline-function 'newline-and-indent)
  (TeX-PDF-mode t)
  (TeX-view-program-list '(("Skim" "/Applications/Skim.app/Contents/SharedSupport/displayline %n %o %b")))
  (TeX-view-program-selection '((output-pdf "Skim")))
  (TeX-auto-local "/tmp/"))
#+END_SRC
*** Python
Emacs has built-in Python support, but this package adds some niceties, including Python shell integration. I also want to customize autopair's behavior here and add a utility to automatically activate a virtualenv if one is found:
#+BEGIN_SRC emacs-lisp
(use-package python-mode
  :ensure t
  :defer t
  :init
  (add-hook 'python-mode-hook (lambda ()
                              (setq autopair-handle-action-fns (list #'autopair-default-handle-action #'autopair-python-triple-quote-action)))))

(use-package auto-virtualenvwrapper
  :ensure t
  :hook (python-mode . auto-virtualenvwrapper-activate)
  :after (python-mode))
#+END_SRC
*** Emacs Lisp
Emacs is naturally good at editing Emacs Lisp, but I want to enable eldoc-mode for inline docs and add a keybinding to recompile the current directory:
#+BEGIN_SRC emacs-lisp
(add-hook 'emacs-lisp-mode-hook (lambda ()
                                  (eldoc-mode 1)
                                  (define-key (current-local-map) "\C-c\C-c" 'byte-recompile-directory)))
#+END_SRC
*** YAML
Emacs doesn't have a good built-in mode for YAML either
#+BEGIN_SRC emacs-lisp
(use-package yaml-mode
  :ensure t
  :defer t)
#+END_SRC
** Work
I use Emacs both for work and for personal projects. It is not uncommon for me to need specific customizations for work that aren't necessarily applicable for personal projects. I've grouped all these here so they're all in one place.

This section is likely to contain snippets with hidden assumptions about the environment that may not be applicable anywhere beyond my work computer.
*** Utilities
Define a function for running processes in the background, outputting to a buffer:
#+BEGIN_SRC emacs-lisp
(defun background-process (command)
  (let ((bufname (generate-new-buffer "*Background Process Output*")))
    (with-current-buffer bufname
      (special-mode))
    (internal-temp-output-buffer-show bufname)
    (start-process-shell-command "background-process" bufname command)))
#+END_SRC
*** Python Black
Use black for formatting Python code:
#+BEGIN_SRC emacs-lisp
(use-package blacken
  :ensure t
  :custom
  (blacken-executable "/Users/ajohnson/.pyenv/shims/black")
  :hook (python-mode . blacken-mode))
#+END_SRC
*** Scala
Define a function to run custom code formatters:
#+BEGIN_SRC emacs-lisp
(defun scala-bazel-format ()
  (interactive)
  (let ((default-directory (projectile-project-root)))
    (background-process "./dev/format-build && ./dev/format-scala")))
#+END_SRC

For Scala, I want to have a keybinding for that custom formatter. I also want a keybinding to jump to the the Bazel build target for the current file. I also have some convenience function to invoke Bazel build/test from a Scala file:
#+BEGIN_SRC emacs-lisp
  (use-package scala-mode
    :ensure t
    :config
    (defun open-bazel-build-for-file ()
      (interactive)
      (let ((fname (file-name-nondirectory (buffer-file-name))))
        (find-file-existing "BUILD")
        (goto-char (point-min))
        (search-forward fname nil t nil)))
    (defun bazel-build-for-file ()
      (interactive)
      (open-bazel-build-for-file)
      (build-current-bazel-target)
      (switch-to-buffer (other-buffer (current-buffer) 1)))
    (defun bazel-test-for-file ()
      (interactive)
      (open-bazel-build-for-file)
      (test-current-bazel-target)
      (switch-to-buffer (other-buffer (current-buffer) 1)))
    :bind (:map scala-mode-map
                ("C-c f" . scala-bazel-format)
                ("C-c b f" . open-bazel-build-for-file)
                ("C-c b b" . bazel-build-for-file)
                ("C-c b t" . bazel-test-for-file)))
#+END_SRC
*** Bazel
When using Bazel for builds, define several helper functions for navigating and running build targets:
#+BEGIN_SRC emacs-lisp
(use-package bazel-mode
  :ensure t
  :config
  (add-to-list 'auto-mode-alist '("\\BUILD$" . bazel-build-mode))
  (add-to-list 'auto-mode-alist '("\\WORKSPACE$" . bazel-workspace-mode))
  (add-to-list 'auto-mode-alist '("\\.sky" . bazel-starlark-mode))

  (defun get-bazel-build-target-name ()
    (unless (looking-at-p ".*(.*\n.*name")
      (re-search-backward "^.*(.*\n.*name" nil t nil))
    (re-search-forward ".*name ?=" nil t nil)
    (let* (
           (dirname (replace-regexp-in-string "/$" ""
                                              (replace-regexp-in-string (projectile-project-root) ""
                                                                        (file-name-directory (buffer-file-name)))))
           (current-line (thing-at-point 'line t))
           (target-name (replace-regexp-in-string ".*name ?= ?\"\\(.*\\)\".*\n" "\\1" current-line)))
      (message "//%s:%s" dirname target-name)))

  (defun copy-bazel-build-target-name ()
    (interactive)
    (kill-new (get-bazel-build-target-name)))

  (defun run-bazel-on-target (command)
    (let ((default-directory (projectile-project-root)))
      (background-process (concat "./bazel " command " " (get-bazel-build-target-name)))))

  (defun build-current-bazel-target ()
    (interactive)
    (run-bazel-on-target "build"))

  (defun test-current-bazel-target ()
    (interactive)
    (run-bazel-on-target "test"))

  :bind (:map bazel-build-mode-map
              ("C-c f" . scala-bazel-format)
              ("C-c b b" . build-current-bazel-target)
              ("C-c b t" . test-current-bazel-target)
              ("C-c b c" . copy-bazel-build-target-name)))
#+END_SRC
*** Terraform
Enable a mode for editing Terraform code, which depends on a base Hashicorp config library:
#+BEGIN_SRC emacs-lisp
(use-package hcl-mode
  :ensure t
  :defer t)

(use-package terraform-mode
  :ensure t
  :defer t
  :after (hcl-mode))
#+END_SRC
*** Puppet
Enable a mode for editing Puppet code:
#+BEGIN_SRC emacs-lisp
(use-package puppet-mode
  :ensure t
  :defer t)
#+END_SRC
*** Schemas
Enable modes for editing Thrift and Protocol Buffer schema definitions:
#+BEGIN_SRC emacs-lisp
(use-package thrift
  :ensure t
  :defer t)
(use-package protobuf-mode
  :ensure t
  :defer t)
#+END_SRC
** Emacs Server
Since Emacs can be a bit slow to start up, I use =emacsclient= to quickly open files in an existing Emacs instance. =server-start= is all that is necessary to enable this.
#+BEGIN_SRC emacs-lisp
(server-start)
#+END_SRC

** Miscellaneous
Finally we have some last miscellaneous settings to configure.
*** Garbage Collection
Finally we set the GC threshold lower for interactive use (this undoes a setting from =early-init.el=). This needs to be the last thing in the file to get the benefits of faster startup.
#+BEGIN_SRC emacs-lisp
(setq gc-cons-threshold (* 2 1000 1000))
#+END_SRC
